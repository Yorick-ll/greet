// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v3.21.12
// source: market.proto

package market

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Request struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Ping          string                 `protobuf:"bytes,1,opt,name=ping,proto3" json:"ping,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Request) Reset() {
	*x = Request{}
	mi := &file_market_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Request) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Request) ProtoMessage() {}

func (x *Request) ProtoReflect() protoreflect.Message {
	mi := &file_market_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Request.ProtoReflect.Descriptor instead.
func (*Request) Descriptor() ([]byte, []int) {
	return file_market_proto_rawDescGZIP(), []int{0}
}

func (x *Request) GetPing() string {
	if x != nil {
		return x.Ping
	}
	return ""
}

type Response struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Pong          string                 `protobuf:"bytes,1,opt,name=pong,proto3" json:"pong,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Response) Reset() {
	*x = Response{}
	mi := &file_market_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Response) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Response) ProtoMessage() {}

func (x *Response) ProtoReflect() protoreflect.Message {
	mi := &file_market_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Response.ProtoReflect.Descriptor instead.
func (*Response) Descriptor() ([]byte, []int) {
	return file_market_proto_rawDescGZIP(), []int{1}
}

func (x *Response) GetPong() string {
	if x != nil {
		return x.Pong
	}
	return ""
}

type GetPairInfoByTokenRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ChainId       int64                  `protobuf:"varint,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	TokenAddress  string                 `protobuf:"bytes,2,opt,name=token_address,json=tokenAddress,proto3" json:"token_address,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetPairInfoByTokenRequest) Reset() {
	*x = GetPairInfoByTokenRequest{}
	mi := &file_market_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetPairInfoByTokenRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetPairInfoByTokenRequest) ProtoMessage() {}

func (x *GetPairInfoByTokenRequest) ProtoReflect() protoreflect.Message {
	mi := &file_market_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetPairInfoByTokenRequest.ProtoReflect.Descriptor instead.
func (*GetPairInfoByTokenRequest) Descriptor() ([]byte, []int) {
	return file_market_proto_rawDescGZIP(), []int{2}
}

func (x *GetPairInfoByTokenRequest) GetChainId() int64 {
	if x != nil {
		return x.ChainId
	}
	return 0
}

func (x *GetPairInfoByTokenRequest) GetTokenAddress() string {
	if x != nil {
		return x.TokenAddress
	}
	return ""
}

type GetPairInfoByTokenResponse struct {
	state                  protoimpl.MessageState `protogen:"open.v1"`
	ChainId                int64                  `protobuf:"varint,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`                                                     // Chain ID
	Address                string                 `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`                                                                     // Trading pair address
	Name                   string                 `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`                                                                           // DEX factory version swap name
	FactoryAddress         string                 `protobuf:"bytes,4,opt,name=factory_address,json=factoryAddress,proto3" json:"factory_address,omitempty"`                                 // Factory contract address
	BaseTokenAddress       string                 `protobuf:"bytes,5,opt,name=base_token_address,json=baseTokenAddress,proto3" json:"base_token_address,omitempty"`                         // Base token address
	TokenAddress           string                 `protobuf:"bytes,6,opt,name=token_address,json=tokenAddress,proto3" json:"token_address,omitempty"`                                       // Token address
	BaseTokenSymbol        string                 `protobuf:"bytes,7,opt,name=base_token_symbol,json=baseTokenSymbol,proto3" json:"base_token_symbol,omitempty"`                            // Base token symbol
	TokenSymbol            string                 `protobuf:"bytes,8,opt,name=token_symbol,json=tokenSymbol,proto3" json:"token_symbol,omitempty"`                                          // Token symbol
	BaseTokenDecimal       int64                  `protobuf:"varint,9,opt,name=base_token_decimal,json=baseTokenDecimal,proto3" json:"base_token_decimal,omitempty"`                        // Base token decimals
	TokenDecimal           int64                  `protobuf:"varint,10,opt,name=token_decimal,json=tokenDecimal,proto3" json:"token_decimal,omitempty"`                                     // Token decimals
	BaseTokenIsNativeToken bool                   `protobuf:"varint,11,opt,name=base_token_is_native_token,json=baseTokenIsNativeToken,proto3" json:"base_token_is_native_token,omitempty"` // Is base token native currency
	BaseTokenIsToken0      bool                   `protobuf:"varint,12,opt,name=base_token_is_token0,json=baseTokenIsToken0,proto3" json:"base_token_is_token0,omitempty"`                  // Is base token token0
	InitBaseTokenAmount    float64                `protobuf:"fixed64,13,opt,name=init_base_token_amount,json=initBaseTokenAmount,proto3" json:"init_base_token_amount,omitempty"`           // Initial base token liquidity
	InitTokenAmount        float64                `protobuf:"fixed64,14,opt,name=init_token_amount,json=initTokenAmount,proto3" json:"init_token_amount,omitempty"`                         // Initial token liquidity
	CurrentBaseTokenAmount float64                `protobuf:"fixed64,15,opt,name=current_base_token_amount,json=currentBaseTokenAmount,proto3" json:"current_base_token_amount,omitempty"`  // Current base token liquidity
	CurrentTokenAmount     float64                `protobuf:"fixed64,16,opt,name=current_token_amount,json=currentTokenAmount,proto3" json:"current_token_amount,omitempty"`                // Current token liquidity
	Fdv                    float64                `protobuf:"fixed64,17,opt,name=fdv,proto3" json:"fdv,omitempty"`                                                                          // Fully diluted valuation
	MktCap                 float64                `protobuf:"fixed64,18,opt,name=mkt_cap,json=mktCap,proto3" json:"mkt_cap,omitempty"`                                                      // Market capitalization
	TokenPrice             float64                `protobuf:"fixed64,19,opt,name=token_price,json=tokenPrice,proto3" json:"token_price,omitempty"`                                          // Token price
	BaseTokenPrice         float64                `protobuf:"fixed64,20,opt,name=base_token_price,json=baseTokenPrice,proto3" json:"base_token_price,omitempty"`                            // Base token price
	BlockNum               int64                  `protobuf:"varint,21,opt,name=block_num,json=blockNum,proto3" json:"block_num,omitempty"`                                                 // Creation block height
	BlockTime              int64                  `protobuf:"varint,22,opt,name=block_time,json=blockTime,proto3" json:"block_time,omitempty"`                                              // Creation block timestamp
	HighestTokenPrice      float64                `protobuf:"fixed64,23,opt,name=highest_token_price,json=highestTokenPrice,proto3" json:"highest_token_price,omitempty"`                   // Highest token price
	LatestTradeTime        int64                  `protobuf:"varint,24,opt,name=latest_trade_time,json=latestTradeTime,proto3" json:"latest_trade_time,omitempty"`                          // Latest on-chain trade timestamp
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *GetPairInfoByTokenResponse) Reset() {
	*x = GetPairInfoByTokenResponse{}
	mi := &file_market_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetPairInfoByTokenResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetPairInfoByTokenResponse) ProtoMessage() {}

func (x *GetPairInfoByTokenResponse) ProtoReflect() protoreflect.Message {
	mi := &file_market_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetPairInfoByTokenResponse.ProtoReflect.Descriptor instead.
func (*GetPairInfoByTokenResponse) Descriptor() ([]byte, []int) {
	return file_market_proto_rawDescGZIP(), []int{3}
}

func (x *GetPairInfoByTokenResponse) GetChainId() int64 {
	if x != nil {
		return x.ChainId
	}
	return 0
}

func (x *GetPairInfoByTokenResponse) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *GetPairInfoByTokenResponse) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *GetPairInfoByTokenResponse) GetFactoryAddress() string {
	if x != nil {
		return x.FactoryAddress
	}
	return ""
}

func (x *GetPairInfoByTokenResponse) GetBaseTokenAddress() string {
	if x != nil {
		return x.BaseTokenAddress
	}
	return ""
}

func (x *GetPairInfoByTokenResponse) GetTokenAddress() string {
	if x != nil {
		return x.TokenAddress
	}
	return ""
}

func (x *GetPairInfoByTokenResponse) GetBaseTokenSymbol() string {
	if x != nil {
		return x.BaseTokenSymbol
	}
	return ""
}

func (x *GetPairInfoByTokenResponse) GetTokenSymbol() string {
	if x != nil {
		return x.TokenSymbol
	}
	return ""
}

func (x *GetPairInfoByTokenResponse) GetBaseTokenDecimal() int64 {
	if x != nil {
		return x.BaseTokenDecimal
	}
	return 0
}

func (x *GetPairInfoByTokenResponse) GetTokenDecimal() int64 {
	if x != nil {
		return x.TokenDecimal
	}
	return 0
}

func (x *GetPairInfoByTokenResponse) GetBaseTokenIsNativeToken() bool {
	if x != nil {
		return x.BaseTokenIsNativeToken
	}
	return false
}

func (x *GetPairInfoByTokenResponse) GetBaseTokenIsToken0() bool {
	if x != nil {
		return x.BaseTokenIsToken0
	}
	return false
}

func (x *GetPairInfoByTokenResponse) GetInitBaseTokenAmount() float64 {
	if x != nil {
		return x.InitBaseTokenAmount
	}
	return 0
}

func (x *GetPairInfoByTokenResponse) GetInitTokenAmount() float64 {
	if x != nil {
		return x.InitTokenAmount
	}
	return 0
}

func (x *GetPairInfoByTokenResponse) GetCurrentBaseTokenAmount() float64 {
	if x != nil {
		return x.CurrentBaseTokenAmount
	}
	return 0
}

func (x *GetPairInfoByTokenResponse) GetCurrentTokenAmount() float64 {
	if x != nil {
		return x.CurrentTokenAmount
	}
	return 0
}

func (x *GetPairInfoByTokenResponse) GetFdv() float64 {
	if x != nil {
		return x.Fdv
	}
	return 0
}

func (x *GetPairInfoByTokenResponse) GetMktCap() float64 {
	if x != nil {
		return x.MktCap
	}
	return 0
}

func (x *GetPairInfoByTokenResponse) GetTokenPrice() float64 {
	if x != nil {
		return x.TokenPrice
	}
	return 0
}

func (x *GetPairInfoByTokenResponse) GetBaseTokenPrice() float64 {
	if x != nil {
		return x.BaseTokenPrice
	}
	return 0
}

func (x *GetPairInfoByTokenResponse) GetBlockNum() int64 {
	if x != nil {
		return x.BlockNum
	}
	return 0
}

func (x *GetPairInfoByTokenResponse) GetBlockTime() int64 {
	if x != nil {
		return x.BlockTime
	}
	return 0
}

func (x *GetPairInfoByTokenResponse) GetHighestTokenPrice() float64 {
	if x != nil {
		return x.HighestTokenPrice
	}
	return 0
}

func (x *GetPairInfoByTokenResponse) GetLatestTradeTime() int64 {
	if x != nil {
		return x.LatestTradeTime
	}
	return 0
}

type GetNativeTokenPriceRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ChainId       int64                  `protobuf:"varint,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	SearchTime    string                 `protobuf:"bytes,2,opt,name=search_time,json=searchTime,proto3" json:"search_time,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetNativeTokenPriceRequest) Reset() {
	*x = GetNativeTokenPriceRequest{}
	mi := &file_market_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetNativeTokenPriceRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetNativeTokenPriceRequest) ProtoMessage() {}

func (x *GetNativeTokenPriceRequest) ProtoReflect() protoreflect.Message {
	mi := &file_market_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetNativeTokenPriceRequest.ProtoReflect.Descriptor instead.
func (*GetNativeTokenPriceRequest) Descriptor() ([]byte, []int) {
	return file_market_proto_rawDescGZIP(), []int{4}
}

func (x *GetNativeTokenPriceRequest) GetChainId() int64 {
	if x != nil {
		return x.ChainId
	}
	return 0
}

func (x *GetNativeTokenPriceRequest) GetSearchTime() string {
	if x != nil {
		return x.SearchTime
	}
	return ""
}

type GetNativeTokenPriceResponse struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	BaseTokenPriceUsd float64                `protobuf:"fixed64,1,opt,name=base_token_price_usd,json=baseTokenPriceUsd,proto3" json:"base_token_price_usd,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *GetNativeTokenPriceResponse) Reset() {
	*x = GetNativeTokenPriceResponse{}
	mi := &file_market_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetNativeTokenPriceResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetNativeTokenPriceResponse) ProtoMessage() {}

func (x *GetNativeTokenPriceResponse) ProtoReflect() protoreflect.Message {
	mi := &file_market_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetNativeTokenPriceResponse.ProtoReflect.Descriptor instead.
func (*GetNativeTokenPriceResponse) Descriptor() ([]byte, []int) {
	return file_market_proto_rawDescGZIP(), []int{5}
}

func (x *GetNativeTokenPriceResponse) GetBaseTokenPriceUsd() float64 {
	if x != nil {
		return x.BaseTokenPriceUsd
	}
	return 0
}

var File_market_proto protoreflect.FileDescriptor

const file_market_proto_rawDesc = "" +
	"\n" +
	"\fmarket.proto\x12\x06market\"\x1d\n" +
	"\aRequest\x12\x12\n" +
	"\x04ping\x18\x01 \x01(\tR\x04ping\"\x1e\n" +
	"\bResponse\x12\x12\n" +
	"\x04pong\x18\x01 \x01(\tR\x04pong\"[\n" +
	"\x19GetPairInfoByTokenRequest\x12\x19\n" +
	"\bchain_id\x18\x01 \x01(\x03R\achainId\x12#\n" +
	"\rtoken_address\x18\x02 \x01(\tR\ftokenAddress\"\xcc\a\n" +
	"\x1aGetPairInfoByTokenResponse\x12\x19\n" +
	"\bchain_id\x18\x01 \x01(\x03R\achainId\x12\x18\n" +
	"\aaddress\x18\x02 \x01(\tR\aaddress\x12\x12\n" +
	"\x04name\x18\x03 \x01(\tR\x04name\x12'\n" +
	"\x0ffactory_address\x18\x04 \x01(\tR\x0efactoryAddress\x12,\n" +
	"\x12base_token_address\x18\x05 \x01(\tR\x10baseTokenAddress\x12#\n" +
	"\rtoken_address\x18\x06 \x01(\tR\ftokenAddress\x12*\n" +
	"\x11base_token_symbol\x18\a \x01(\tR\x0fbaseTokenSymbol\x12!\n" +
	"\ftoken_symbol\x18\b \x01(\tR\vtokenSymbol\x12,\n" +
	"\x12base_token_decimal\x18\t \x01(\x03R\x10baseTokenDecimal\x12#\n" +
	"\rtoken_decimal\x18\n" +
	" \x01(\x03R\ftokenDecimal\x12:\n" +
	"\x1abase_token_is_native_token\x18\v \x01(\bR\x16baseTokenIsNativeToken\x12/\n" +
	"\x14base_token_is_token0\x18\f \x01(\bR\x11baseTokenIsToken0\x123\n" +
	"\x16init_base_token_amount\x18\r \x01(\x01R\x13initBaseTokenAmount\x12*\n" +
	"\x11init_token_amount\x18\x0e \x01(\x01R\x0finitTokenAmount\x129\n" +
	"\x19current_base_token_amount\x18\x0f \x01(\x01R\x16currentBaseTokenAmount\x120\n" +
	"\x14current_token_amount\x18\x10 \x01(\x01R\x12currentTokenAmount\x12\x10\n" +
	"\x03fdv\x18\x11 \x01(\x01R\x03fdv\x12\x17\n" +
	"\amkt_cap\x18\x12 \x01(\x01R\x06mktCap\x12\x1f\n" +
	"\vtoken_price\x18\x13 \x01(\x01R\n" +
	"tokenPrice\x12(\n" +
	"\x10base_token_price\x18\x14 \x01(\x01R\x0ebaseTokenPrice\x12\x1b\n" +
	"\tblock_num\x18\x15 \x01(\x03R\bblockNum\x12\x1d\n" +
	"\n" +
	"block_time\x18\x16 \x01(\x03R\tblockTime\x12.\n" +
	"\x13highest_token_price\x18\x17 \x01(\x01R\x11highestTokenPrice\x12*\n" +
	"\x11latest_trade_time\x18\x18 \x01(\x03R\x0flatestTradeTime\"X\n" +
	"\x1aGetNativeTokenPriceRequest\x12\x19\n" +
	"\bchain_id\x18\x01 \x01(\x03R\achainId\x12\x1f\n" +
	"\vsearch_time\x18\x02 \x01(\tR\n" +
	"searchTime\"N\n" +
	"\x1bGetNativeTokenPriceResponse\x12/\n" +
	"\x14base_token_price_usd\x18\x01 \x01(\x01R\x11baseTokenPriceUsd2\xf0\x01\n" +
	"\x06Market\x12)\n" +
	"\x04Ping\x12\x0f.market.Request\x1a\x10.market.Response\x12[\n" +
	"\x12GetPairInfoByToken\x12!.market.GetPairInfoByTokenRequest\x1a\".market.GetPairInfoByTokenResponse\x12^\n" +
	"\x13GetNativeTokenPrice\x12\".market.GetNativeTokenPriceRequest\x1a#.market.GetNativeTokenPriceResponseB\n" +
	"Z\b./marketb\x06proto3"

var (
	file_market_proto_rawDescOnce sync.Once
	file_market_proto_rawDescData []byte
)

func file_market_proto_rawDescGZIP() []byte {
	file_market_proto_rawDescOnce.Do(func() {
		file_market_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_market_proto_rawDesc), len(file_market_proto_rawDesc)))
	})
	return file_market_proto_rawDescData
}

var file_market_proto_msgTypes = make([]protoimpl.MessageInfo, 6)
var file_market_proto_goTypes = []any{
	(*Request)(nil),                     // 0: market.Request
	(*Response)(nil),                    // 1: market.Response
	(*GetPairInfoByTokenRequest)(nil),   // 2: market.GetPairInfoByTokenRequest
	(*GetPairInfoByTokenResponse)(nil),  // 3: market.GetPairInfoByTokenResponse
	(*GetNativeTokenPriceRequest)(nil),  // 4: market.GetNativeTokenPriceRequest
	(*GetNativeTokenPriceResponse)(nil), // 5: market.GetNativeTokenPriceResponse
}
var file_market_proto_depIdxs = []int32{
	0, // 0: market.Market.Ping:input_type -> market.Request
	2, // 1: market.Market.GetPairInfoByToken:input_type -> market.GetPairInfoByTokenRequest
	4, // 2: market.Market.GetNativeTokenPrice:input_type -> market.GetNativeTokenPriceRequest
	1, // 3: market.Market.Ping:output_type -> market.Response
	3, // 4: market.Market.GetPairInfoByToken:output_type -> market.GetPairInfoByTokenResponse
	5, // 5: market.Market.GetNativeTokenPrice:output_type -> market.GetNativeTokenPriceResponse
	3, // [3:6] is the sub-list for method output_type
	0, // [0:3] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_market_proto_init() }
func file_market_proto_init() {
	if File_market_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_market_proto_rawDesc), len(file_market_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   6,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_market_proto_goTypes,
		DependencyIndexes: file_market_proto_depIdxs,
		MessageInfos:      file_market_proto_msgTypes,
	}.Build()
	File_market_proto = out.File
	file_market_proto_goTypes = nil
	file_market_proto_depIdxs = nil
}
